<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: error.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: error.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>(function (){
    var register = require("register-js");

    /*
     * A simple hack to error.
     *
     */
    var systemError = Error;

    /**
     * Create a new Error
     *
     * @class Error
     * @name Error
     * @constructor
     * @param {String|Number|Object}         errorNumber   The error string, or an error number, or an error descriptor.
     * @param {...(Array.&lt;String>|String)=}  formatString  An array of string for replacement.
     * @param {Object=}                      extraData     The extra data to display
     * @param {Error=}                       previousError The previous error met.
     * @returns {Error} Created javascript error.
     *
     * @example
     *      new Error("Failed to open file {0}", "/home/karl/test.js");
     *
     * @example
     *      new Error(Error.login.NO_NAME);
     */
    var error = function (/*{String|Number|Object}*/      errorNumber,
                          /*...(Array.&lt;String>|String)=*/ formatString,
                          /*Object=*/                     extraData,
                          /*Error=*/                      previousError)
    {
        var descriptor = error.prototype.initializeMessageString.apply(this, arguments);

        var sysError = systemError.call(this, descriptor.message);
        sysError.constructor = systemError;
        sysError.extra = typeof arguments[2] === "object" ? extraData: undefined;
        sysError.previous = typeof arguments[3] === "object" ? previousError: undefined;

        //Copy everything inside descriptor
        for(var x in descriptor)
            sysError[x] = descriptor[x];

        return sysError;
    };

    /**
     * Initialize a new
     * @name Error.prototype.initializeMessageString
     * @method
     * @param {String|Number|Object}         errorNumber   The error string, or an error number, or an error descriptor.
     * @param {...(Array.&lt;String>|String)=}  formatString  An array of string for replacement.
     * @returns {string} The  message string replaced by formatStrings.
     */
    error.prototype.initializeMessageString = function (/*{String|Number|Object}*/        errorNumber,
                                                        /*{...(Array.&lt;String>|String)=}*/ formatString){
        var tErrorNumber = typeof errorNumber;
        var err = {};

        if(tErrorNumber === "number"){
            err = error[errorNumber];
        }else if(tErrorNumber === "string"){
            if(errorNumber.match(/\\w[\\w\\._0-9]*/g)){
                err = error.getError(errorNumber);
            }else err = { desc: errorNumber };
        }else{
            err = errorNumber;
        }

        if(!err)
            err = { desc: errorNumber };

        //Now we've got the err object, we need to parse it if there has lang object.
        //This API is reserved for further development.
        for(var y in err)
            error.handleKeywords(y, err);

        var extern = [];

        if(typeof formatString === "array" ||
           typeof formatString === "object"){
            for(var x in formatString)
                extern[x] = formatString[x];

            extern.unshift(err.desc);
        } else {
            if(arguments.length > 0)
                //arguments.shift();
                //This can not be done for jasmine-node
                Array.prototype.shift.call(arguments);

            extern.push(err.desc);
            var element;

            //They are not regarded to be an array for Jasime. Fuck it.
            for(var i = 0; i&lt;arguments.length; i++){
                element = Array.prototype.shift.call(arguments);
                if(element)
                    extern.push(element);
            }
        }

        err.message = error.stringFormatter.apply(this, extern);
        return err;
    };

    ///////////////////////////////////////
    //
    // Hack the string
    //
    ///////////////////////////////////////
    // First, checks if it isn't implemented yet.
    if (!String.prototype.format) {
        String.prototype.format = function() {
            if(arguments.length &lt;= 1) return this;

            var args = arguments;
            return this.replace(/{(\d+)}/g, function(match, number) {
                return typeof args[number] != 'undefined' ? args[number] : match;
            });
        };
    }

    if (!String.format) {
        String.format = function(format) {
            if(arguments.length &lt;= 1){
                return format;
            }

            var args = Array.prototype.slice.call(arguments, 1);
            return format.replace(/{(\d+)}/g, function(match, number) {
                return typeof args[number] != 'undefined' ? args[number] : match;
            });
        };
    }

    error.stringFormatter = String.format;

    /**
     * @name StringFormatter
     * @type function(string, ...string=)
     * @param {string} formatString Like "%d" or "{0} Hello World."
     * @param {...string=} replacementString Like "1000", to replace those holes.
     * @callback StringFormatter
     * @return {String} The string formatted. Like "1000 Hello World" against "{0} Hello World".
     *
     * @example
     *      function formatter(string, ...);
     *      formatter("Merry {0}! from {1}", "Christmas", "Paul") ===> "Merry Christmas! from Paul"
     *
     */

    /**
     * Set the string formatter of error.
     * @name Error.setStringFormatter
     * @static
     * @method
     * @param {StringFormatter} formatter A string formatter. The default formatter formats c# style
     *                                                        strings.
     */
    error.setStringFormatter = function (/*StringFormatter*/ formatter){
        error.stringFormatter = formatter;
    };

    /**
     * Get current using formatter
     * @name Error.getStringFormatter
     * @static
     * @method
     * @returns {StringFormatter} Return the string formatter.
     */
    error.getStringFormatter = function (){
        return error.stringFormatter;
    };


    var node = true;
    if(typeof window === "object") node = false;

    var errors = [];
    var fileType = "json";
    var keywords = {};
    var validationKeywords = {};
    var cachedPackageNames = [];
    var ignoranceRules = [/^error$/i];

    /**
     * @name KeywordHandler
     * @summary A handler when scanning descriptor. System will find the corresponding keyword as the name
     *          of a descriptor attribute.
     * @param {*}      value Like "%d" or "{0} Hello World."
     * @param {Object} descriptor Like "1000", to replace those holes.
     * @callback KeywordHandler
     * @return {String} The string formatted. Like "1000 Hello World" against "{0} Hello World".
     *
     * @example
     *      //Descriptor will be like this:
     *      {
     *          "id": 1,
     *          "desc": "Hello World",
     *          "lang": "en-US"
     *      }
     *
     *      //Then you can add your own handler like this:
     *      KeywordHandler.add("lang", function (value, descriptor){
     *          console.log(value);
     *          descriptor.desc = languages[value];
     *      });
     *
     *      //console output:
     *      en-US
     */

    /**
     * Add a keyword for translate descriptors. When creating new Error object, it will parse
     * the descriptor, and handle all descriptor attributes. Each attribute of descriptor will
     * be corresponding to an keyword.
     *
     * @method
     * @static
     * @name Error.addKeywordHandler
     *
     * @param {String}         keyword The keyword to detect.
     * @param {KeywordHandler} handler The event handler.
     *
     * @see KeywordHandler
     */
    error.addKeywordHandler = function (/*String*/ keyword, /*function*/ handler){
        keywords[keyword] = handler;
    };

    /**
     * Remove a keyword for translate descriptors.
     * @see Error.addKeywordHandler
     * @see KeywordHandler
     *
     * @method
     * @static
     * @name Error.removeKeywordHandler
     *
     * @param {String}         keyword The keyword to detect.
     * @param {KeywordHandler} handler The event handler.
     *
     * @see KeywordHandler
     */
    error.removeKeywordHandler = function (/*String*/ keyword){
        delete keywords[keyword];
    };

    /**
     * Handle the keyword we've by calling its registration in keywords array.
     * @param keyword The keyword the function asked.
     * @param descriptor The error descriptor.
     */
    error.handleKeywords = function (/*string*/ keyword, /*Object*/ descriptor){
        if(typeof keywords[keyword] === "function")
            keywords[keyword](descriptor[keyword], descriptor);
    };

    //Add additional keyword code if name is exists.
    function keywordCode(/*string*/ keyword, /*Object*/ descriptor){
        var name = descriptor.name;
        if(typeof name === "string" && !isBlank(name) &&
            typeof descriptor.code === "undefined"){
            descriptor.code = name;
        }
    }

    //Add additional keyword errno for id
    function keywordId(/*string*/ keyword, /*Object*/ descriptor){
        descriptor.errno = keyword;
    }

    error.addKeywordHandler("name", keywordCode);
    error.addKeywordHandler("id", keywordId);

    // Array Remove - By John Resig (MIT Licensed)
    if(typeof Array.prototype.remove === "undefined")
        Array.prototype.remove = function(from, to) {
            var rest = Array.prototype.slice.call(this, (to || from) + 1 || this.length);
            this.length = from &lt; 0 ? this.length + from : from;
            return Array.prototype.push.apply(this, rest);
        };

    /**
     * Register one error by its descriptor, register a collection of errors.
     * @method Error.register
     * @static
     * @param {Array|Object} errorDescriptors   A collection of error descriptors.
     * @param {String=}    defaultPackageName The default package name to put before error package names.
     */
    error.register = function (/*Object*/ errorDescriptors, /*String=""*/ defaultPackageName){
        if(arguments.length > 2)
            return error.registerOne(arguments[0], arguments[1], arguments[2], arguments[3]);

        if(typeof errorDescriptors != "object")
            throw new Error("Registered error should be an object");

        var success = true;

        if("name" in errorDescriptors && "id" in errorDescriptors){
            realRegisterOne(errorDescriptors.name, errorDescriptors.id, errorDescriptors, defaultPackageName);
        }
        else {
            for(var x in errorDescriptors){
                var descriptor = errorDescriptors[x];
                success &= error.registerOne(x, descriptor.id, descriptor.desc, descriptor, defaultPackageName);
            }
        }
        return success;
    };

    /**
     * Detect if a string is null or empty or blank.
     * @param str The string need to be detected.
     * @returns {boolean} True for yes, false for no.
     */
    function isBlank(/*String*/str) {
        return (!str || /^\s*$/.test(str));
    }

    /**
     * Add a new ignorance package rule.
     *
     * Ignorance is a string or a regex used to remove unnecessary words from default namespaces.
     *
     * This function is used when you want to store your errors under a folder with specific names,
     * and then you should provide the correct name with {@see Error.require}.
     *
     * @method Error.addIgnoranceRules
     * @static
     *
     * @param {RegExp|String|Array.&lt;RegExp|String>}rules The regex rule or string descriptor of ignorance rule
     *
     * @example
     *      Error.addIgnoranceRules("error"); // "org.cauchies.error.login" => org.cauchies.login
     *      Error.addIgnoranceRules(/error/i); //"org.cauchies.Error.login" => org.caucheis.login
     */
    error.addIgnoranceRules = function (/*RegExp|String|Array.&lt;RegExp|String>*/rules){
        if((typeof rules === "object" && rules.constructor != RegExp) || typeof rules === "array" )
            for(var x in rules)
            {
                ignoranceRules.push(rules[x]);
            }
        else
            ignoranceRules.push(rules);
    };

    /**
     * Get all ignorance rules.
     * @returns {RegExp[]} Return the ignorance rules of package name
     */
    error.getIgnoranceRules = function (){
        return ignoranceRules;
    };

    /**
     * Get ignorance rule array size
     * @returns {Number} The ignorance rules array size.
     */
    error.getIgnoranceRuleCount = function (){
        return ignoranceRules.length;
    };

    /**
     * Clear all ignorance rules.
     */
    error.clearIgnoranceRules = function (){
        ignoranceRules = [];
    };

    /**
     * Remove one rule of ignorance rules.
     * @param rules The rules to delete.
     */
    error.removeIgnoranceRule = function (/*Regex|String*/ rules){
        for(var i = 0; i&lt;ignoranceRules.length; i++)
        {
            if(ignoranceRules[i] === rules)
                ignoranceRules.remove(i);
        }
    };

    /**
     * Restore ignorance rules to the initial status.
     */
    error.restoreIgnoranceRules = function (){
        ignoranceRules = [/error/i];
    };

    /**
     * Detect if a string need to be ignored.
     * @param detect The string to be detected.
     * @returns {boolean} True for yes, false for no.
     */
    var isIgnore = function (/*String*/ detect){
        if(isBlank(detect)) return true;

        for(var i=0; i&lt;ignoranceRules.length; i++){
            if(detect.match(ignoranceRules[i]))
                return true;
        }

        return false;
    };

    /**
     * Get the full package name by adding defaultPackageName with name.
     *
     * This function has a cache strategy, which will help the system got right answer.
     *
     * @param name The name of an object
     * @param defaultPackageName The default package name.
     * @returns {String} Return "DefaultPackageName.Name"
     */
    error.getFullPackageName = function (/*Name*/ name, /*String=""*/defaultPackageName){
        if(typeof defaultPackageName === "undefined" || isBlank(defaultPackageName))
            return name;

        if(defaultPackageName in cachedPackageNames)
            return cachedPackageNames[defaultPackageName] + name;

        var array = defaultPackageName.split(/[.\/]/g);
        var arraylength = array.length;
        var result = "";
        for(var i = 0; i&lt;arraylength; i++)
        {
            var element = array.shift();
            if(isIgnore(element)){
                //Delete the element called error.
                continue;
            }

            //Try to stick them together.
            result += element + "." ;
        }

        cachedPackageNames[defaultPackageName] = result;
        return result + name;
    };

    error.clearPackageNameCache = function (){
        cachedPackageNames = [];
    };

    /**
     * Register one error into standard error cache.
     * @param errorName The name of error.
     * @param id The id of error
     * @param descriptor The error descriptor object
     * @param defaultPackageName The default package name to be put before the name in json file.
     * @returns {boolean} True for success, false for failure.
     */
    function realRegisterOne(/*String*/errorName, /*Number*/id,
                             /*String|Object*/descriptor, /*String=""*/ defaultPackageName) {
        var element = {}, result = false,
            name = error.getFullPackageName(errorName, defaultPackageName);

        if ((result = error.validateKeywords(element, descriptor))) {
            //register element.
            register.registerPackage(element, name, error);
            error[id] = element;

            errors[name] = element;
        }

        return result;
    }

    /**
     * Register one error, with its name and id.
     * @param errorName The error name including the full namespace.
     * @param id  The id of error.
     * @param description The description strings.
     * @param descriptor Extra descriptors
     * @param defaultPackageName The default package name to be put before the name in json file.
     * @return True for success, false for failure.
     */
    error.registerOne = function (/*String*/ errorName,
                                  /*Integer*/ id,
                                  /*String|Object*/ description,
                                  /*Object=*/ descriptor,
                                  /*String=""*/ defaultPackageName){
        var fullName = error.getFullPackageName(errorName, defaultPackageName);

        if(typeof descriptor === "undefined"){
            descriptor = {
                name: fullName,
                id: id,
                desc: description
            };
        }

        return realRegisterOne(fullName, id, descriptor);
    };

    /**
     * Return the error by its namespace or id.
     * @param idOrName Error's id or name.
     * @returns {Object} The error descriptor.
     */
    error.getError = function (/*String|Number*/ idOrName){
        if(typeof idOrName === "string")
            return register.getPackage(idOrName, error);

        return error[idOrName];
    };

    /**
     * Add custom keywords.
     * @param keyword  The keyword of description
     * @param callback The callback function when we reach that.
     */
    error.addKeywordValidator = function (/*String*/keyword, /*Function*/callback){
        validationKeywords[keyword] = callback;
    };

    /**
     * validate all keywords.
     * @param element The element storage.
     * @param descriptor The descriptor of an error.
     * @returns {boolean} True for success, false for failure.
     */
    error.validateKeywords = function (element, descriptor){
        var valid = true;

        for(var x in descriptor)
        {
            if(x in validationKeywords){
                var value = descriptor[x];
                valid &= validationKeywords[x](value, element, descriptor, x);
            }
        }

        return valid;
    };

    /**
     * Validation callback of "name" element.
     *
     * Require: The name is never being used.
     *
     * @param errorName The error name, including package.
     * @param element The element to be registered.
     * @returns {boolean} True for success, false for not important failure.
     */
    var validateErrorName = function (errorName, element){
        var _package = register.getPackage(errorName, error);

        if(_package)
            throw new Error("The package \"" + errorName + "\" has already been used.");

        switch(errorName)
        {
            case "name":
            case "id":
            case "desc":
            case "lang":
                throw new Error("Error name \""+errorName+"\" is reserved.");

            default:
                if(typeof error[errorName] === "function"){
                    throw new Error("Error name \""+errorName+"\" has been taken from service functions.");
                }
        }

        element.name = errorName;

        return true;
    };

    /**
     * Validation callback of "id" element.
     *
     * Require: The id is never being used and it must be a number.
     *
     * @param id The error id, it must be a number.
     * @param element The element to be registered.
     * @returns {boolean} True for success, false for not important failure.
     */
    var validateErrorId = function (id, element){
        if(typeof id != "number")
            throw new Error("Id should be a number");

        var _id = error[id];
        if(_id)
            throw new Error("The id \"" + id + "\" has already been used.");

        element.id = id;
        return true;
    };

    /**
     * Validation callback of "desc" element.
     *
     * @param desc The error descriptor. If that is an object, it should be a valid "language" object.
     * @param element The element to be registered.
     * @returns {boolean} Always return true.
     */
    var validateDescription = function (desc, element){
        if(typeof desc === "object"){
            element.lang = desc;
        }
        else {
            element.desc = desc;
        }

        return true;
    };

    var validateCode = function (desc, element){
        element.code = desc;
        return true;
    };

    var validateErrno = function (desc, element){
        element.errno = desc;
        return true;
    };

    error.addKeywordValidator("name", validateErrorName);
    error.addKeywordValidator("id",   validateErrorId);
    error.addKeywordValidator("desc", validateDescription);
    error.addKeywordValidator("code", validateCode);
    error.addKeywordValidator("errno", validateErrno);

    /**
     * Set the remote loading file file. such as "json" or "js"
     * @param type The file type string.
     */
    error.setFileType = function (/*String=json*/ type){
        if(typeof type != "string") requireJSON.fileType = "json";

        requireJSON.fileType = type;
    };

    /**
     * Get current remote loading file type.
     * @returns {string} The file type of system.
     */
    error.getFileType = function (){
        return requireJSON.fileType;
    };

    /**
     * Remove all registered errors.
     * @return {Number} The elements deleted.
     */
    error.clearAllError = function (){
        var i = 0;

        for(var x in errors){
            var valid = error.removeError(errors[x]);

            if(valid){ i++; }
        }

        return i;
    };

    /**
     * Remove one error.
     * @param errorElement An error descriptor. Either be errorName, errorId, or the descriptor.
     * @returns {boolean} True for success, false for failure.
     */
    error.removeError = function (/*Object|String|Number*/ errorElement){
        var type = typeof errorElement,
            name = false;

        switch(type){
            case "object": name = errorElement.name; break;
            case "string": name = errorElement; break;
            case "number": name = error[errorElement]; break;
        }

        if(!name) return false;

        //If the error element package doesn't exist.
        var _package = null;
        if(!(_package = register.getPackage(name, error)))
            return false;

        //Now remove the package, including name and id
        register.removePackage(_package.name, error);

        delete error[_package.id];
        delete errors[_package.name];

        return true;
    };

    /**
     * Return the error array contains all errors.
     * @returns {Array}
     */
    error.getErrors = function (){
        return errors;
    };

    /**
     * Return the number of errors.
     * @returns {data.number.count|*|count|Test.count|number}
     */
    error.getErrorCount =  function (){
        return errors.length;
    };

    /**
     * Load error config files from its package name.
     * @param nodePackage
     * @param browserPackage
     * @returns {*}
     */
    error.require = function (/*String*/ nodePackage, /*String*/browserPackage){
        var json = requireJSON(nodePackage, browserPackage);
        var _packageName = nodePackage;
        if(typeof browserPackage === "string") _packageName = browserPackage;

        return error.register(json, _packageName);
    };

    /**
     * Pack a json file and turn it into a js file.
     * @param nodePackage
     * @param browserPackage
     */
    error.pack = function (/*String*/ nodePackage, /*String*/browserPackage){
        var json = requireJSON(nodePackage, browserPackage);
        var _packageName = nodePackage;
        if(typeof browserPackage === "string") _packageName = browserPackage;

        var string = "register(" +JSON.stringify(json) + ", \"requireJSON.cacheSymbol." +
                    error.getFullPackageName(_packageName) +
                    "\", module);";

        return string;
    };

    register(error, "error", module);

    if(node)
        GLOBAL.Exception = error;
    else
        window.Exception = error;

    /*jshint -W020*/
    Error = error;
    /**
     * Resume standard Error
     * @method Error.noConflict
     * @static
     * @returns {Exception} The custom error class
     */
    error.noConflict = function (){
        Error = systemError;
        return error;
    };

    //We need to register it.
    register(error, "error-js", module);
})();</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Error.html">Error</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Wed Mar 26 2014 17:30:05 GMT+0800 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
