(function (){

    var register = require("register-js");

    /*
     * A simple hack to error.
     *
     */
    var systemError = Error;

    /**
     *
     * @returns {error}
     * @constructor
     */

    var error = function (a,b, extraData, previousError)
    {
        var message = error.prototype.initializeMessageString.apply(this, arguments);

        var sysError = systemError.call(this, message);
        sysError.constructor = systemError;
        sysError.extra = typeof arguments[2] === "object" ? extraData: undefined;
        sysError.previous = typeof arguments[3] === "object" ? previousError: undefined;

        return sysError;
    };

    error.prototype.initializeMessageString = function (/*String|Number*/      errorNumber,
                                     /*Array=*/            formatString,
                                     /*Object=*/              extraData,
                                     /*Error|Exception=*/ previousError){
        var tErrorNumber = typeof errorNumber;
        var err = {};

        if(tErrorNumber === "number"){
            err = error[errorNumber];
        }else if(tErrorNumber === "string"){
            if(errorNumber.match(/\\w[\\w\\._0-9]*/g)){
                err = error.getError(errorNumber);
            }else err = { desc: errorNumber };
        }else{
            err = errorNumber;
        }

        if(!err)
            err = { desc: errorNumber };

        //Now we've got the err object, we need to parse it if there has lang object.
        //This API is reserved for further development.
        for(var y in err)
            error.handleKeywords(y, err);

        var extern = [];

        if(typeof formatString === "array" ||
           typeof formatString === "object"){
            for(var x in formatString)
                extern[x] = formatString[x];

            extern.unshift(err.desc);
        } else {
            if(arguments.length > 0)
                //arguments.shift();
                //This can not be done for jasmine-node
                Array.prototype.shift.call(arguments);

            extern.push(err.desc);
            var element;

            //They are not regarded to be an array for Jasime. Fuck it.
            for(var i = 0; i<arguments.length; i++){
                element = Array.prototype.shift.call(arguments);
                if(element)
                    extern.push(element);
            }
        }

        return error.stringFormatter.apply(this, extern);
    };

    ///////////////////////////////////////
    //
    // Hack the string
    //
    ///////////////////////////////////////
    // First, checks if it isn't implemented yet.
    if (!String.prototype.format) {
        String.prototype.format = function() {
            if(arguments.length <= 1) return this;

            var args = arguments;
            return this.replace(/{(\d+)}/g, function(match, number) {
                return typeof args[number] != 'undefined' ? args[number] : match;
            });
        };
    }

    if (!String.format) {
        String.format = function(format) {
            if(arguments.length <= 1){
                return format;
            }

            var args = Array.prototype.slice.call(arguments, 1);
            return format.replace(/{(\d+)}/g, function(match, number) {
                return typeof args[number] != 'undefined' ? args[number] : match;
            });
        };
    }

    error.stringFormatter = String.format;

    /**
     * Set the string formatter of error.
     * @param formatter
     */
    error.setStringFormatter = function (/*function*/ formatter){
        error.stringFormatter = formatter;
    };

    /**
     * Get the error's string formatter.
     * @returns {format|*} Return the formatter.
     */
    error.getStringFormatter = function (){
        return error.stringFormatter;
    };

    error.addKeywordHandler = function (/*String*/ keyword, /*function*/ handler){
        keywords[keyword] = handler;
    };

    error.removeKeywordHandler = function (/*String*/ keyword){
        delete keywords[keyword];
    };

    error.handleKeywords = function (/*keyword*/ keyword, /*Object*/ descriptor){
        if(typeof keywords[keyword] === "function")
            keywords[keyword](descriptor[keyword], descriptor);
    };

    var node = true;
    if(typeof window === "object") node = false;

    var errors = [];
    var fileType = "json";
    var keywords = {};
    var validationKeywords = {};
    var cachedPackageNames = [];
    var ignoranceRules = [/^error$/i];

    // Array Remove - By John Resig (MIT Licensed)
    if(typeof Array.prototype.remove === "undefined")
        Array.prototype.remove = function(from, to) {
            var rest = Array.prototype.slice.call(this, (to || from) + 1 || this.length);
            this.length = from < 0 ? this.length + from : from;
            return Array.prototype.push.apply(this, rest);
        };

    /**
     * Register a collection of error or one element
     * @param errorDescriptors A collection of error descriptors.
     */
    error.register = function (/*Object*/ errorDescriptors, /*String=""*/ defaultPackageName){
        if(arguments.length > 2)
            return error.registerOne(arguments[0], arguments[1], arguments[2], arguments[3]);

        if(typeof errorDescriptors != "object")
            throw new Error("Registered error should be an object");

        var success = true;

        if("name" in errorDescriptors && "id" in errorDescriptors){
            realRegisterOne(errorDescriptors.name, errorDescriptors.id, errorDescriptors, defaultPackageName);
        }
        else {
            for(var x in errorDescriptors){
                var descriptor = errorDescriptors[x];
                success &= error.registerOne(x, descriptor.id, descriptor.desc, descriptor, defaultPackageName);
            }
        }
        return success;
    };

    /**
     * Detect if a string is null or empty or blank.
     * @param str The string need to be detected.
     * @returns {boolean} True for yes, false for no.
     */
    function isBlank(/*String*/str) {
        return (!str || /^\s*$/.test(str));
    }

    /**
     * Add a new ignorance package rule.
     * @param rules The regex rule or string descriptor of ignorance rule
     */
    error.addIgnoranceRules = function (/*Regex|String|Array.<Regex|String>*/rules){
        if((typeof rules === "object" && rules.constructor != RegExp) || typeof rules === "array" )
            for(var x in rules)
            {
                ignoranceRules.push(rules[x]);
            }
        else
            ignoranceRules.push(rules);
    };

    /**
     * Get ignorance rules.
     * @returns {RegExp[]} Return the ignorance rules of package name
     */
    error.getIgnoranceRules = function (){
        return ignoranceRules;
    };

    /**
     * Get ignorance rule array size
     * @returns {Number} The ignorance rules array size.
     */
    error.getIgnoranceRuleCount = function (){
        return ignoranceRules.length;
    };

    /**
     * Clear all ignorance rules.
     */
    error.clearIgnoranceRules = function (){
        ignoranceRules = [];
    };

    /**
     * Remove one rule of ignorance rules.
     * @param rules The rules to delete.
     */
    error.removeIgnoranceRule = function (/*Regex|String*/ rules){
        for(var i = 0; i<ignoranceRules.length; i++)
        {
            if(ignoranceRules[i] === rules)
                ignoranceRules.remove(i);
        }
    };

    /**
     * Restore ignorance rules to the initial status.
     */
    error.restoreIgnoranceRules = function (){
        ignoranceRules = [/error/i];
    };

    /**
     * Detect if a string need to be ignored.
     * @param detect The string to be detected.
     * @returns {boolean} True for yes, false for no.
     */
    var isIgnore = function (/*String*/ detect){
        if(isBlank(detect)) return true;

        for(var i=0; i<ignoranceRules.length; i++){
            if(detect.match(ignoranceRules[i]))
                return true;
        }

        return false;
    };

    /**
     * Get the full package name by adding defaultPackageName with name.
     *
     * This function has a cache strategy, which will help the system got right answer.
     *
     * @param name The name of an object
     * @param defaultPackageName The default package name.
     * @returns {String} Return "DefaultPackageName.Name"
     */
    error.getFullPackageName = function (/*Name*/ name, /*String=""*/defaultPackageName){
        if(typeof defaultPackageName === "undefined" || isBlank(defaultPackageName))
            return name;

        if(defaultPackageName in cachedPackageNames)
            return cachedPackageNames[defaultPackageName] + name;

        var array = defaultPackageName.split(/[.\/]/g);
        var arraylength = array.length;
        var result = "";
        for(var i = 0; i<arraylength; i++)
        {
            var element = array.shift();
            if(isIgnore(element)){
                //Delete the element called error.
                continue;
            }

            //Try to stick them together.
            result += element + "." ;
        }

        cachedPackageNames[defaultPackageName] = result;
        return result + name;
    };

    error.clearPackageNameCache = function (){
        cachedPackageNames = [];
    };

    /**
     * Register one error into standard error cache.
     * @param errorName The name of error.
     * @param id The id of error
     * @param descriptor The error descriptor object
     * @returns {boolean} True for success, false for failure.
     */
    function realRegisterOne(/*String*/errorName, /*Number*/id,
                             /*String|Object*/descriptor, /*String=""*/ defaultPackageName) {
        var element = {}, result = false,
            name = error.getFullPackageName(errorName, defaultPackageName);

        if ((result = error.validateKeywords(element, descriptor))) {
            //register element.
            register.registerPackage(element, name, error);
            error[id] = element;

            errors[name] = element;
        }

        return result;
    }

    /**
     * Register one error, with its name and id.
     * @param errorName The error name including the full namespace.
     * @param id  The id of error.
     * @param description The description strings.
     * @param descriptor Extra descriptors
     */
    error.registerOne = function (/*String*/ errorName,
                                  /*Integer*/ id,
                                  /*String|Object*/ description,
                                  /*Object=*/ descriptor,
                                  /*String=""*/ defaultPackageName){
        var fullName = error.getFullPackageName(errorName, defaultPackageName);

        if(typeof descriptor === "undefined"){
            descriptor = {
                name: fullName,
                id: id,
                desc: description
            };
        }

        return realRegisterOne(fullName, id, descriptor);
    };

    /**
     * Return the error by its namespace or id.
     * @param idOrName Error's id or name.
     * @returns {Object} The error descriptor.
     */
    error.getError = function (/*String|Number*/ idOrName){
        if(typeof idOrName === "string")
            return register.getPackage(idOrName, error);

        return error[idOrName];
    };

    /**
     * Add custom keywords.
     * @param keyword  The keyword of description
     * @param callback The callback function when we reach that.
     */
    error.addKeywordValidator = function (/*String*/keyword, /*Function*/callback){
        validationKeywords[keyword] = callback;
    };

    /**
     * validate all keywords.
     * @param element The element storage.
     * @param descriptor The descriptor of an error.
     * @returns {boolean} True for success, false for failure.
     */
    error.validateKeywords = function (element, descriptor){
        var valid = true;

        for(var x in descriptor)
        {
            if(x in validationKeywords){
                var value = descriptor[x];
                valid &= validationKeywords[x](value, element, descriptor, x);
            }
        }

        return valid;
    };

    /**
     * Validation callback of "name" element.
     *
     * Require: The name is never being used.
     *
     * @param errorName The error name, including package.
     * @param element The element to be registered.
     * @returns {boolean} True for success, false for not important failure.
     */
    var validateErrorName = function (errorName, element){
        var _package = register.getPackage(errorName, error);

        if(_package)
            throw new Error("The package \"" + errorName + "\" has already been used.");

        switch(errorName)
        {
            case "name":
            case "id":
            case "desc":
            case "lang":
                throw new Error("Error name \""+errorName+"\" is reserved.");

            default:
                if(typeof error[errorName] === "function"){
                    throw new Error("Error name \""+errorName+"\" has been taken from service functions.");
                }
        }

        element.name = errorName;

        return true;
    };

    /**
     * Validation callback of "id" element.
     *
     * Require: The id is never being used and it must be a number.
     *
     * @param id The error id, it must be a number.
     * @param element The element to be registered.
     * @returns {boolean} True for success, false for not important failure.
     */
    var validateErrorId = function (id, element){
        if(typeof id != "number")
            throw new Error("Id should be a number");

        var _id = error[id];
        if(_id)
            throw new Error("The id \"" + id + "\" has already been used.");

        element.id = id;
        return true;
    };

    /**
     * Validation callback of "desc" element.
     *
     * @param desc The error descriptor. If that is an object, it should be a valid "language" object.
     * @param element The element to be registered.
     * @returns {boolean} Always return true.
     */
    var validateDescription = function (desc, element){
        if(typeof desc === "object"){
            element.lang = desc;
        }
        else {
            element.desc = desc;
        }

        return true;
    };

    error.addKeywordValidator("name", validateErrorName);
    error.addKeywordValidator("id",   validateErrorId);
    error.addKeywordValidator("desc", validateDescription);

    /**
     * Set the remote loading file file. such as "json" or "js"
     * @param type The file type string.
     */
    error.setFileType = function (/*String=json*/ type){
        if(typeof type != "string") requireJSON.fileType = "json";

        requireJSON.fileType = type;
    };

    /**
     * Get current remote loading file type.
     * @returns {string} The file type of system.
     */
    error.getFileType = function (){
        return requireJSON.fileType;
    };

    /**
     * Remove all registered errors.
     * @return {Number} The elements deleted.
     */
    error.clearAllError = function (){
        var i = 0;

        for(var x in errors){
            var valid = error.removeError(errors[x]);

            if(valid){ i++; }
        }

        return i;
    };

    /**
     * Remove one error.
     * @param errorElement An error descriptor. Either be errorName, errorId, or the descriptor.
     * @returns {boolean} True for success, false for failure.
     */
    error.removeError = function (/*Object|String|Number*/ errorElement){
        var type = typeof errorElement,
            name = false;

        switch(type){
            case "object": name = errorElement.name; break;
            case "string": name = errorElement; break;
            case "number": name = error[errorElement]; break;
        }

        if(!name) return false;

        //If the error element package doesn't exist.
        var _package = null;
        if(!(_package = register.getPackage(name, error)))
            return false;

        //Now remove the package, including name and id
        register.removePackage(_package.name, error);

        delete error[_package.id];
        delete errors[_package.name];

        return true;
    };

    /**
     * Return the error array contains all errors.
     * @returns {Array}
     */
    error.getErrors = function (){
        return errors;
    };

    /**
     * Return the number of errors.
     * @returns {data.number.count|*|count|Test.count|number}
     */
    error.getErrorCount =  function (){
        return errors.length;
    };

    /**
     * Load error config files from its package name.
     * @param nodePackage
     * @param browserPackage
     * @returns {*}
     */
    error.require = function (/*String*/ nodePackage, /*String*/browserPackage){
        var json = requireJSON(nodePackage, browserPackage);
        var _packageName = nodePackage;
        if(typeof browserPackage === "string") _packageName = browserPackage;

        return error.register(json, _packageName);
    };

    /**
     * Pack a json file and turn it into a js file.
     * @param nodePackage
     * @param browserPackage
     */
    error.pack = function (/*String*/ nodePackage, /*String*/browserPackage){
        var json = requireJSON(nodePackage, browserPackage);
        var _packageName = nodePackage;
        if(typeof browserPackage === "string") _packageName = browserPackage;

        var string = "register(" +JSON.stringify(json) + ", \"requireJSON.cacheSymbol." +
                    error.getFullPackageName(_packageName) +
                    "\", module);";

        return string;
    };

    register(error, "error", module);

    if(node)
        GLOBAL.Exception = error;
    else
        window.Exception = error;
})();